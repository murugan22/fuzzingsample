Task 1: TLV Parsing 
    Checks for four conditions: 
    - The first byte of the packet is not a valid L2TPv3 header.-- done
    - There are no TLVs present in the packet -done
    - The length of the value is lesser than actual length-done
    - The length of the value is missing-done

    Add ons/ suggestions - if the length of the value is greater than the actual length, 
    then it needs to be fuzzed entirely -done

    ##TESTING UPDATE

    \x01\x00\x03abcde\x01\x00\x02a - string put to test

    the value printed is abc when it should be abcde as we are testing if the length of the value is greater than the actual length
    the error to be detected in the first tlv pack is - length of value greater than actual length
    the error to be detected in the second packet is incorrect byte length - this is not detected as the loop breaks due to "Error: Other error: object of type 'int' has no len()"
                        
Task 2: Fuzzing for each TLV error code
    - Generates randomly for each error from 0 to 255 bytes for length number of iterations

    Add ons/ suggestions  - can the fuzzing take place based on the type under the TLV (int, bool, string)

    ##TESTING UPDATE
    Fuzzing values need to be between 0 to 255.

Task 3: Integrate the complete logic for a jvm 
    In oldjvmfuzzer.py, the logic is parse the file and find "main". Under main they replace all instructions by fuzzing, that is start with an "", run it as a subprocess and keep adding bytes and check again. The bytes are added, checked, validateed and backtracked based on the error code or exception generated by the jvm. The error codes are classified into Complete, Incomplete or Bad. 

    When the VM is reading the data in TLV or related formats, it reads in _length_ value, and then proceeds to read in as much data as given in the just read length value. We have to go back and forth to parse.

    We need to detect when the length_value is read through the jvm and generate error codes (missing byte, incomplete data ...) based on the exceptions produced by the JVM as done by the previous logic. Based on these error codes along with the previous ones, we fuzz accordingly.



